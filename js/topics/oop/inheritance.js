// 'use strict';

/**
|--------------------------------------------------
  === <<<---  INHERITANCE | НАСЛЕДОВАНИЕ --->>>  ===
  https://www.youtube.com/watch?v=0e9eyrxB-LU&list=PLwHvxJae2LazDrHm6ayqLKz6jszEn7ArQ&index=1
JS - это мультипарадигменный язык программирования.
JS поддерживает несколько подходов к написанию компьютерных программ:
  1. объектноориентированный
  2. прототипноориентированный
  3. функциональный

  Из-за этого в JS есть несколько принципиально различных способов унаследовать один класс от другого, что приводит к немалой путаницы.
|--------------------------------------------------
*/


// // === <<<--- Option I - 1-й способ наследования - псевдокласовый или декларативный --->>>  ===

// class Cat {

//   constructor (catName) {
//     this.name = catName;
//   }

//   getName () {
//     return this.name;
//   }
// }


// class BobCat extends Cat {

//   constructor (catName) {
//     super(catName);

//     this.weight = 30;
//     this.color = "orange";
//   }
// }


// var david = new BobCat("David");
// document.write(david.getName());



// // === <<<--- Option II - 2-й способ наследования - происходит из функциональный парадигмы программирования --->>>  ===

// function Cat (catName) {

//   var name = catName;

//   this.getName = function () {
//     return name
//   }
// };


// function BobCat (catName) {

//   Cat.call(this, catName);

//     this.weight = 30;
//     this.color = "orange";
// }


// var david = new BobCat("David");
// document.write(david.getName());



// // === <<<--- Option III - 3-й способ наследования в JS - прототипный --->>>  ===
/* 
Прототип - это что-то вроди ссылки на класс родителя
Когда на экземпляре какого-либо класса обращаемся к свойству, или методу, то это свойство или метод в перую очередь осуществлять поиск в теле самого класса, что логично.
Если это свойство, или метод в теле класса не обнаружено, то будет искаться в теле класса прототипа.
Если его не обнаружено и там, то это свойство, или метод будет искаться в прототипа его прототипа и так дальше.

При прототипном наследовании мы должны создать экземпляр нашего родительского класса - это принципиальное отличие прототипного наследования от декларативного. Прототипом какого-либо класса является именно объект другого класса.
*/

// function Cat (catName) {
//   var name = catName;

//   this.getName = function () {
//     return name
//   }
// };


// function BobCat (catName) {

//     this.weight = 30;
//     this.color = "orange";
// }

// // создаем экземпляр класса Cat и передаем имя кота "David"
// var cat = new Cat ("David");

// // Выполняем непосредственно наследование
// // Через свойство prototype указываем, прототипом класса BobCat будет экземпляр класса cat 
// BobCat.prototype = cat;

// // Непосредственно создаем экземпляр класса BobCat 
// var david = new BobCat();

// // BobCat может обращаться к свойствам и методам класса cat
// document.write(david.getName());







