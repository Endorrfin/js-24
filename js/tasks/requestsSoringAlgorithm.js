
/*
ðŸŽ¯ There are two services that return a list of active loan requests sorted by ID in ascending order.
    The ID is cross-cutting across both services.
    In other words, the ID is unique and is automatically generated by randomly placing the request into one of the two databases.
    The services then receive two lists from two different databases. The data in both databases is unique.
    Task: Get a list of the k most recent loan requests.
    I'm waiting for two solutions:
    1. The easiest way.
    2. The most optimal way (memory, time).
 */

    const getDecision1 = [
  {id: 1, result: 'approved'},
  {id: 3, result: 'waiting'},
  {id: 15, result: 'approved'},
  {id: 20, result: 'approved'},
  {id: 26, result: 'waiting'},
  {id: 1, result: 'approved'},
];

const getDecision2 = [
  {id: 2, result: 'approved'},
  {id: 4, result: 'waiting'},
  {id: 14, result: 'approved'},
  {id: 16, result: 'approved'},
  {id: 23, result: 'waiting'},
  {id: 32, result: 'approved'},
];

// const getLastDecision = (decision1, decision2, k) => {
// // Solution
//
// };
//
// const getLastDecision(getDecisioo1, getDecisioo2, 5);
// const getLastDecision(getDecisioo1, getDecisioo2, 7);



// ============================================================
// SOLUTION 1: EASIEST WAY
// ============================================================
// Merge, sort descending, slice k elements
// Time: O((n+m) * log(n+m)), Space: O(n+m)
const getLastDecisionEasy = (decision1, decision2, k) => {
  return [...decision1, ...decision2] // Merge arrays
      .sort((a, b) => b.id - a.id) // Sort by ID descending
      .slice(0, k); // Take first k elements
};





// ============================================================
// SOLUTION 2: MOST OPTIMAL WAY
// ============================================================
// Two-pointer approach from the end of both sorted arrays
// Time: O(k), Space: O(k)
const getLastDecisionOptimal = (decision1, decision2, k) => {
  const result = [];
  let i = decision1.length - 1; // Pointer for decision1 (from end)
  let j = decision2.length - 1; // Pointer for decision2 (from end)

  while (result.length < k && (i >= 0 || j >= 0)) { //Continue until k elements or exhausted
    if (i < 0) {
      result.push(decision2[j--]); // Only decision2 left
    } else if (j < 0) {
      result.push(decision1[i--]); // Only decision1 left
    } else if (decision1[i].id > decision2[j].id) {
      result.push(decision1[i--]); // decision1 has larger ID
    } else {
      result.push(decision2[j--]); // decision2 has larger ID
    }
  }

  return result; // Already in descending order
};

// Usage
console.log('Easy k=5:', getLastDecisionEasy(getDecision1, getDecision2, 5));
console.log('Optimal k=5:', getLastDecisionOptimal(getDecision1, getDecision2, 5));

console.log('Easy k=7:', getLastDecisionEasy(getDecision1, getDecision2, 7));
console.log('Optimal k=7:', getLastDecisionOptimal(getDecision1, getDecision2, 7));


